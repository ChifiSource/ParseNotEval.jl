var documenterSearchIndex = {"docs":
[{"location":"overview/#ParseNotEval","page":"Overview","title":"ParseNotEval","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Modules = [ParseNotEval]","category":"page"},{"location":"overview/#ParseNotEval.ParseNotEval","page":"Overview","title":"ParseNotEval.ParseNotEval","text":"Created in April, 2022 by chifi - an open source software dynasty. by team odd-data This software is MIT-licensed.\n\nParseNotEval\n\nA module which extends Julia's parse() method to work with a set number of types. This is useful for file readers and recieving types through a request. If you     are using this module, it is likely through OddFrames -> OddStructures\n\nModule Composition\n\nParseNotEval - High-level API\n\n\n\n\n\n","category":"module"},{"location":"overview/#Base.parse-Tuple{AbstractString}","page":"Overview","title":"Base.parse","text":"parse(s::AbstractString) -> ::Any\n\nBinded call for parse(::DataType{Any}, ::AbstractString). Parses string into     assumed type. arguments\n\nT <: DataType; type to parse s into.\ns <: AbstractString; string to be parsed into type T.\n\n\n\nexample\n\nparse(\"55\")\nInt64(55)\n\n\n\n\n\n","category":"method"},{"location":"overview/#Base.parse-Tuple{Type, AbstractArray}","page":"Overview","title":"Base.parse","text":"parse(T::Type{Pair}, s::AbstractArray) -> ::Array{T}\n\nParses each element inside of of s into type T. Replaces arguments that cannot be casted with missing. arguments\n\nT <: DataType; type to parse s into.\ns <: AbstractArray; the array to be casted.\n\n\n\nexample\n\nexample_input = [\"55\", \"82\", \"hello\"]\nnew = parse(Int64, example_input)\nnew\n[55, 82, missing]\n\n\n\n\n\n","category":"method"},{"location":"overview/#Base.parse-Tuple{Type, Pair}","page":"Overview","title":"Base.parse","text":"parse(T::Type{Pair}, s::Pair) -> ::Pair{Symbol, T}\n\nParses the pair value s[2] into type T. arguments\n\nT <: DataType; type to parse s into.\ns <: AbstractArray; the array to be casted.\n\n\n\nexample\n\nexample_input::Pair = :A => \"5\"\nnew::Pair = parse(Int64, example_input)\nnew\n:A => 5\n\n\n\n\n\n","category":"method"},{"location":"overview/#Base.parse-Tuple{Type{Any}, AbstractString}","page":"Overview","title":"Base.parse","text":"parse(T::Type{Any}, s::AbstractString) -> ::Any\n\nTrys to guess the type of a string implicitly. For a more explicit assumption of type, try passing the type as the first argument. arguments\n\nT <: DataType; type to parse s into.\ns <: AbstractString; string to be parsed into type T.\n\n\n\nexample\n\nexample_input = \"[5, 10, 15, 20]\"\nmy_array::Array{Int64} = parse(Array, example_input)\n[5, 10, 15, 20]\n\nexample_input = \"5\"\nmyint::Int64 = parse(Any, example_input)\n\n\n\n\n\n","category":"method"},{"location":"overview/#Base.parse-Tuple{Type{Array}, AbstractString}","page":"Overview","title":"Base.parse","text":"parse(T::Type{Array}, s::AbstractString) -> ::Array{typeof(parse(Any, s))}\n\nParses s into type T. arguments\n\nT <: DataType; type to parse s into.\ns <: AbstractString; string to be parsed into type T.\n\n\n\nexample\n\nexample_input = \"[5, 10, 15, 20]\"\nmy_array::Array{Int64} = parse(Array, example_input)\n[5, 10, 15, 20]\nmy_array::Array{Float64} = parse(Float64, my_array)\n[5.0, 10.0, 15.0, 20.0]\n\n\n\n\n\n","category":"method"},{"location":"overview/#Base.parse-Tuple{Type{DateTime}, AbstractString}","page":"Overview","title":"Base.parse","text":"parse(T::Type{DateTime}, s::AbstractString) -> ::DateTime\n\nParses a date with time, with appropriate formatting, from string to date. Requires '-' and ':' separators be used. arguments\n\nT <: DataType; type to parse s into.\ns <: AbstractString; string to be parsed into type T.\n\n\n\nexample\n\nexample_input::String = \"1999-11-23:8000\"\nsymb::DateTime = parse(DateTime, example_input)\ntypeof(myint) == DateTime\ntrue\n\n\n\n\n\n","category":"method"},{"location":"overview/#Base.parse-Tuple{Type{Date}, AbstractString}","page":"Overview","title":"Base.parse","text":"parse(T::Type{Date}, s::AbstractString) -> ::Date\n\nParses a date, with appropriate formatting, from string to date. Requires '-' separators be used. arguments\n\nT <: DataType; type to parse s into.\ns <: AbstractString; string to be parsed into type T.\n\n\n\nexample\n\nexample_input::String = \"1999-11-23\"\nsymb::Date = parse(Date, example_input)\ntypeof(myint) == Date\ntrue\n\n\n\n\n\n","category":"method"},{"location":"overview/#Base.parse-Tuple{Type{Dict}, AbstractString}","page":"Overview","title":"Base.parse","text":"parse(T::Type{Dict}, s::AbstractString) -> ::Dict\n\nParses a dict. Can inclkude any of the following examples of input:\n\nJSON data; e.g. \"{A:5, x:6}\"\nDict data; e.g. \"A => [5, 10, 15, 20], B => [5, 10, 15, 20]\"\n\narguments\n\nT <: DataType; type to parse s into.\ns <: AbstractString; string to be parsed into type T.\n\n\n\nexample\n\nexample_input::String = \"{x => [5, 10, 15], y = [5, 8, 7]}\"\nmy_dct::Dict = parse(Dict, example_input)\n\nexample_input::String = \"{x : [5, 10, 15], y : [5, 8, 7]}\"\nmy_dct::Dict = parse(Dict, example_input)\n\ntypeof(myint) == Dict\ntrue\n\n\n\n\n\n","category":"method"},{"location":"overview/#Base.parse-Tuple{Type{Pair}, AbstractString}","page":"Overview","title":"Base.parse","text":"parse(T::Type{Pair}, s::AbstractString) -> ::Pair\n\nParses a string s into type T. arguments\n\nT <: DataType; type to parse s into.\ns <: AbstractString; string to be parsed into type T.\n\n\n\nexample\n\nexample_input::String = \"x => 5\"\nsymb::Pair = parse(Pair, example_input)\ntypeof(myint) == Pair\ntrue\n\n\n\n\n\n","category":"method"},{"location":"overview/#Base.parse-Tuple{Type{String}, AbstractString}","page":"Overview","title":"Base.parse","text":"parse(T::Type{String}, s::AbstractString) -> ::String\n\nAlthough parsing a string into a string is not necessary, the reason why the binding exists is so that if dims are parsed by type, they can still have a     normal return whenever they are strings. arguments\n\nT <: DataType; type to parse s into.\ns <: AbstractString; string to be parsed into type T.\n\n\n\nexample\n\nexample_input = \"5\"\nmyint::Int64 = parse(String, example_input)\ntypeof(myint) == String\ntrue\n\n\n\n\n\n","category":"method"},{"location":"overview/#Base.parse-Tuple{Type{Symbol}, AbstractString}","page":"Overview","title":"Base.parse","text":"parse(T::Type{Symbol}, s::AbstractString) -> ::Symbol\n\nParses a symbol, without the colon. It is really a simple binded call to the constructor Symbol(::AbstractString). arguments\n\nT <: DataType; type to parse s into.\ns <: AbstractString; string to be parsed into type T.\n\n\n\nexample\n\nexample_input::String = \"hello\"\nsymb::Symbol = parse(Symbol, example_input)\n\n:hello\n\ntypeof(myint) == Symbol\ntrue\n\n\n\n\n\n","category":"method"}]
}
